// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float> popcount;
StructuredBuffer<float> growths;
RWStructuredBuffer<int> teamOf;
//StructuredBuffer<float> teamGrowth;
int2 dime;

struct Inf{
    int x;
    int y;
    float strength;
    int team;
    int isArmy;
};

int numInfs;
StructuredBuffer<Inf> infs; 


[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int index = (id.y * dime.x) + id.x;

    float md = 100000;
    for(int i = 0; i < numInfs; i++){ 

        int2 pos = int2(infs[i].x, infs[i].y);
        float dist = distance(pos, id.xy) + 0.01;

        //is one if dist < md;
        int cl = step(dist, md);

        //when cl is one, assign new distance
        //when cl is 0, write old distance
        md = dist * cl + (1 - cl) * md;
    }
    float cityPower = 1 / pow(md, 0.7);
    cityPower = clamp(cityPower, 0, 1);
    
    //ignore boundary texels
    if(id.x < (uint)1 || id.x > dime.x - (uint)1){
        return;
    }
    if(id.y < (uint)1 || id.y > dime.y - (uint)1){return;}

    //count surrounding population and "live" squares
    float totPop = 0;
    int sur = 0;
    int lsur = 0;
    for(int x = 0; x < 3; x++){
        int xindex = index + (x - 1);
        int yindex;

        for(int y = 0; y < 3; y++){
            yindex = xindex + (y - 1) * dime.x;
            totPop += popcount[yindex];

            //this adds up high density cells used for overpop calculations
            sur += step(0.8, popcount[yindex]);

            //this adds up low density cells used for expansion
            lsur += step(0.2, popcount[yindex]);
        }
    }
    float avg = totPop * 0.111;
    float mypop = popcount[index];
    cityPower *= min(8, totPop * 0.5);

    // extant shrink step
    //int minp = step(1, sur);

    //only grow if there are some live tiles nearby
    //int growp = step(3, sur);

    //imposes cellular automata growth pattern
    //int maxG = step(6, sur);

    //this step limits growth by distance from city
    //float maxPop = (1.2 + cityPower) * ((maxG * 0.1) + (1 - maxG)) * pow(cityPower + 0.05, 0.7);
    //maxPop = min(maxPop, 2.5);
    //int overp = step(maxPop, mypop);

    //overp = min(1, overp);

    //amount change per tick (second)
    float delt = 0.01;

    //dynamic max pop calculation based on distance from city (md)
    float cmaxPop = pow(cityPower * 1, 0.5) + pow(cityPower * 1, 2);
    cmaxPop = min(2, cmaxPop);
    cmaxPop -= step(7, sur);

    //shrink if over population cap
    int shrinkmask = step(cmaxPop, mypop);//max(0, min(1, cmaxPop)); //totPop?


    //grow if over min spec
    int growmask = step(1.9, step(6, lsur) + step(2, sur)); 
    int minigrowth = step(3, lsur) * (1 - step(2, sur)) * (1 - step(8, lsur));
    minigrowth += step(mypop, avg * 0.8);
    float growth = growmask * delt * sur * (1 - shrinkmask) * cityPower;
    growth += minigrowth * delt * 1;

    float shrink = shrinkmask * -delt * cityPower;// * (1 / lsur + 0.01);

    float newPop = mypop + growth * (1 - shrinkmask) + shrink;

    //step to prevent zero-ing out a cell
    //the lower bound is twice the "cityPower", a nonlinear calculation that correlates
    //with the distance from the current texel to the nearest city center

    int alive = step(0.01, newPop);
    float diff = newPop - mypop;
    int drop = step(diff, 0); //1 if pop is decreasing

    float floor = alive * max(newPop, mypop);//(lsur * 0.11) * cityPower * 2);
    popcount[index] = drop * floor + (1 - drop) * newPop;
}
